#' @title Parallel version of multilinear interpolation generator for function approximation
#' @param evalfun The objective function to be approximated.
#' @param grid_list A list for grid points (each element of list is a vector represents ticklabels on a dimension). The number of list elements are the dimension of function inputs.
#' @param cores The numbers of cores (threads) of your machine to conduct parallel computing.
#' @param ... Other inputs for objective functions to be passed through.
#' @return \code{interpolation} returns
#' \itemize{
#'       \item{value: }{A list of of length p corresponding to each variable. Returns NA for continuous variable; proportion of zeros for binary/truncated variables; the cumulative proportions of zeros and ones (e.g. first value is proportion of zeros, second value is proportion of zeros and ones) for ternary variable. }
#'       \item{interpolant: }{An interpolant function generated by \code{chebpol::chebpol} for interplation.}
#' @export
#' @import doFuture
#' @import foreach
#' @importFrom parallel detectCores
#' @importFrom chebpol ipol
#' @examples
#'
interpolation = function(evalfun, grid_list, cores = detectCores(), ...) {
  grid_all = expand.grid(grid_list)
  registerDoFuture()
  plan(multicore, workers = cores)
  value_vector =
    foreach (j = 1:nrow(grid_all), .combine = c) %dopar% {
      grid_input = as.numeric(grid_all[j, ])
      value_list = evalfun(grid_input = grid_input, ...)
    }
  d_grid = length(grid_list)
  dim_value = NULL
  for (i in 1:d_grid) {
    dim_value = c(dim_value, length(grid_list[[i]]))
  }
  value = array(value_vector, dim = dim_value)
  interpolant = ipol(val = value, grid = grid_list, method = "multilin")
  return (list(value = value, interpolant = interpolant))
}
